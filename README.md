# django_hw1
Домашняя работа по Джанго. 


# DJANGO ORM
[Домашнаяя работа](https://my.sky.pro/student-cabinet/stream-lesson/118580/homework-requirements)  

## Задание 1  
Подключите `СУБД PostgreSQL` для работы в проекте, для этого:

- Создайте базу данных в ручном режиме.
- Внесите изменения в настройки подключения.  
_Мы уже работали с этой СУБД **на курсе «Работа с базами данных»**. В уроке **17.1 «Введение в работу с базами данных»** подробно описан процесс создания базы данных._  

## Задание 2  
В приложении каталога создайте модели:  

`Product`,  
`Category`.  
Опишите для них начальные настройки.

К начальным настройкам модели относятся метод `__str__` и `class Meta` с описанием свойств модели.  

## Задание 3  
Для каждой модели опишите следующие поля:  

`Product`  
- Наименование  
- Описание  
- Изображение (превью)  
- Категория  
- Цена за покупку  
- Дата создания (записи в БД)  
- Дата последнего изменения (записи в БД)  

`Category`  
- Наименование  
- Описание  
Свяжите продукт и категорию, используя связь между таблицами «Один ко многим».  


У одной категории может быть много продуктов, но у одного продукта может быть только одна категория.  

Воспользуйтесь специальным полем модели — **`ForeignKey()`**.  
При необходимости подробнее про то, как работает такое поле, можно почитать [тут](https://metanit.com/python/django/5.6.php).    

Поля **«Дата создания»** и **«Дата последнего изменения»** стали стандартом для моделей. Их общепринятые названия — **_created_at_** и **_updated_at_** соответственно.

### Примечание  

Для поля с изображением необходимо добавить соответствующие настройки (MEDIA URL, MEDIA ROOT, настроить URL для отображения медиаданных) в проект, а также установить библиотеку для работы с изображениями `Pillow`. Не забудьте обновить файл с зависимостями для проекта после установки новой библиотеки.  


## Задание 4
Перенесите отображение моделей в базу данных с помощью инструмента миграций, для этого:  

- создайте миграции для новых моделей;
- примените миграции;
- внесите изменения в модель продукта, добавьте поле «Дата производства продукта» (manufactured_at), примените обновление структуры с помощью миграций;
- откатите миграцию до состояния, когда поле «Дата производства продукта» (manufactured_at) для модели продукта еще не существовало, и удалите лишнюю миграцию.
Важно сохранять всю историю миграций проекта для сохранения целостности базы данных проекта.  

Не забудьте добавить все выполненные миграции в коммит, а затем отправить в удаленный репозиторий на GitHub.  

#### Подсказка
Чтобы сбросить миграцию до определенной (по номеру), можно воспользоваться командой `python manage.py migrate имя_приложения номер_миграции` (например, 0003)  
Номер миграции написан в названии файла.


## Задание 5
Для моделей категории и продукта настройте отображение в административной панели. Для категорий выведите `id` и `наименование` в список отображения, а для продуктов выведите в список `id`, `название`, `цену` и `категорию`.

При этом интерфейс вывода продуктов настройте так, чтобы можно было результат отображения фильтровать по категории, а также осуществлять поиск по названию и полю описания.

 

#### Подсказка
Все настройки производите в файле `admin.py`.

Для управления полями, которые выводятся в списке в панели администратора, используйте настройку `list_display`, для настройки фильтров — `list_filter`, для управления поиском по полям — `search_fields`

В общем случае настройки административной панели для модели будут выглядеть следующим образом:

@admin.register(Имя_модели)  
class Имя_МоделиAdmin(admin.ModelAdmin):  
    list_display = (список_полей_модели_для_отображения)  
    list_filter = (список_полей_для_фильтрации)  
    search_fields = (список_полей_для_поиска)  

Используйте различные настройки для управления функционалом административной панели. Использовать все три настройки одновременно необязательно.

## Задание 6
1. Через инструмент `shell` заполните список категорий, а также выберите список категорий, применив произвольные рассмотренные фильтры. В качестве решения приложите скриншот.
Установите библиотеку `ipython` для комфортной работы с инструментом `shell`. 
Не забудьте зафиксировать изменения в файле зависимостей проекта.

 

#### Подсказка
В рамках задания реализуйте **ORM-запросы** на создание объектов, получение всех объектов, получение одного объекта по `id`, фильтрацию объектов по определенному полю и исключение объектов из выборки.

Для доступа к объектам используйте команду `Model.objects…` и дополняйте ее различными методами.

Документацию для методов взаимодействия с базой данных через `Django ORM` можно найти [тут](https://docs.djangoproject.com/en/5.0/topics/db/queries/).

Чтобы создать объект, необходимо использовать метод `create()` и перечислить все обязательные поля

Чтобы получить список всех объектов, необходимо использовать метод `all()`.

Чтобы получить один объект, используйте метод `get()`.

Чтобы отфильтровать объекты по определенному значению поля, необходимо использовать метод `filter()` и указать в скобках `имя_поля=”значение_поля”`.

Чтобы исключить объекты из выборки по определенному значению поля, необходимо использовать метод 
`exclude()`
 и указать в скобках 
`имя_поля=”значение_поля”`.  

2. Сформируйте фикстуры для заполнения базы данных.  
Фикстуры создайте командой. Для управления кодировкой используйте опцию 
`-Xutf8`
 для команды. Такой параметр уместно будет использовать на операционной системе `Windows`.

В общем случае команда для создания фикстур будет выглядеть следующим образом:

`python -Xutf8 manage.py dumpdata` имя_приложения > имя_папки_с_фикстурами/имя_приложения_data.json

Напишите кастомную команду, которая умеет заполнять данные в базу данных, при этом предварительно ее зачищать от старых данных.
 

#### Подсказка
Удалите все объекты с помощью `ORM-запроса` 
`Модель.objects.all().delete()`. Удалить необходимо продукты и категории.

Сначала создайте категории, а затем создайте продукты, так как модели связаны между собой.

Считайте данные из `JSON-файла`, который сформировали командой в шаге ранее.

В методе 
`handle()`
 циклично пройдите данные из JSON и положите в список объект, который вы создадите на основе этих данных.

Для связывания объектов используйте ORM-запрос на получение данных из БД.


В общем случае команда будет выглядеть так:

    `class Command(BaseCommand):`

    @staticmethod
    def json_read_categories():
        # Здесь мы получаем данные из фикстурв с категориями

    @staticmethod
    def json_read_products():
        # Здесь мы получаем данные из фикстурв с продуктами

    def handle(self, *args, **options):

        # Удалите все продукты
				# Удалите все категории

				# Создайте списки для хранения объектов
        product_for_create = []
        category_for_create = []

				# Обходим все значения категорий из фиктсуры для получения информации об одном объекте
        for category in Command.json_read_categories():
            category_for_create.append(
                Category(название_поля=значение_из_словаря, ..., название_поля=значение_из_словаря)
            )

				# Создаем объекты в базе с помощью метода bulk_create()
        Category.objects.bulk_create(category_for_create)

				# Обходим все значения продуктов из фиктсуры для получения информации об одном объекте
        for product in Command.json_read_products():
            product_for_create.append(
                Product(название_поля=значение_из_словаря, ..., 
												# получаем категорию из базы данных для корректной связки объектов
                        поле_категории=Category.objects.get(pk=значение_из_словаря), ..., 
                        название_поля=значение_из_словаря)
            )

				# Создаем объекты в базе с помощью метода bulk_create()
        Product.objects.bulk_create(product_for_create)

#### Примечание

Последний пункт можно реализовать в связке с инструментом работы с фикстурами, можно описать вставку данных отдельными запросами.

**Дополнительное задание**  
В контроллер отображения главной страницы добавить выборку последних пяти товаров и вывод их в консоль.
Создать модель для хранения контактных данных и попробовать вывести данные, заполненные через админку, на страницу с контактами.
**Примечание:** дополнительные задания, помеченные звездочкой, желательны, но не обязательны к выполнению.


# Настройка окружения (.env)
импортируемый модуль для настройки окружения - Библиотека для .env [python-decouple](https://pypi.org/project/python-decouple/)  
создайте файл .env  
пример заполнения файла находится в файле(.env.template):      
[postgresql]  
DATABASE_ENGINE=django.db.backends.postgresql  
DATABASE_NAME=django_orm_products  
DATABASE_USER=postgres  
DATABASE_PASSWORD=your_password  
DATABASE_HOST=localhost  
DATABASE_PORT=5432

## шаги по задаче

## Задание 1
1. создать БД вручную в `cmd`  
`psql -U postgres`  
`create database django_orm_products;`  

2. прописываем настройки сервера в settings.py
ENGINE='django.db.backends.postgresql'  
DATABASE_NAME='django_orm_products'  
DATABASE_USER='postgres'  
DATABASE_PASSWORD= config("database_password")

3. Устанавливаем библиотеку
poetry add psycopg2-binary

4. Настраиваем переменные окружения database.ini + config_db.py

## Задание 2 и Задание 3
1. Создаем модели Products and Category  
описываем поля  
Meta  
`__str__`  

2. Добавляем библиотеку для работы с изображениями
poetry add Pillow
3. Делаем миграцию
python manage.py makemigrations             
Migrations for 'catalog':  
  catalog\migrations\0001_initial.py  
4. Применяем миграцию 
python manage.py migrate
5. push to GitHub

## Задание 4
1. внесите изменения в модель продукта, добавьте поле «Дата производства продукта» (`manufactured_at`), примените обновление структуры с помощью миграций;  
2. python manage.py makemigrations
3. python manage.py migrate  
Создание и применение миграции с измененным полем в products


python manage.py migrate catalog 0001  
Operations to perform:  
  Target specific migration: 0001_initial, from catalog  
Running migrations:  
  Rendering model states... DONE  
  Unapplying catalog.0002_remove_product_date_change_and_more... OK

